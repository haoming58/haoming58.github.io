---
layout: note_with_toc
title: 字符串
description: Understanding strings, and practical implementations in algorithm problems
category: Code
subcategory: Algorithme
tags: [strings, Data Structure, Algorithm, Python]
permalink: /notes/strings/
redirect_from:
  - /notes/字符串/
---

# 字符串

字符串对于我来说，相对比较熟悉，因此， 不进行过多描述，直接进入代码实践。 


## 1.1 代码实践

## 1.1 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

示例 2：
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]


### 1.1.1 思路

思路一，使用 for 循环

```python

class Solution():

    def reverse_str(self, word: str) -> str:
        n = len(word) - 1
        result = []

        while n >= 0:
            result.append(word[n])
            n = n - 1

        return "".join(result)
      
```

思路二，采用双指针的方式。 
str 是数组的形式的话，就不用自己在进行创建数组。

```python

class Solution:
    def reverse_str(self, word: str) -> str:
        chars = list(word)   # 字符串 → 列表
        left = 0
        right = len(chars) - 1

        while left < right:
            chars[left], chars[right] = chars[right], chars[left]
            left += 1
            right -= 1

        return "".join(chars)  # 列表 → 字符串

```

思路三，使用栈

后进先出（LIFO）

```python

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        stack = []
        for char in s:
            stack.append(char)
        for i in range(len(s)):
            s[i] = stack.pop()

```

思路四，也是双指针，但是是更简单版本


```python
class Solution():
  def reversestr(self, s:list[str])->None:

    n = len(s)

    for i in range(n//2):
     s[i], s[n - i - 1] = s[n - i - 1], s[i]

```

思路五，直接使用库函数进行操作。或者使用切片

s.reverse() / s[::-1]


## 1.2 反转字符串II

给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。

如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

示例:

输入: s = "abcdefg", k = 2
输出: "bacdfeg"

Python 切片越界不会报错，会自动截断

这是面试和刷题中常用切片而不用索引的原因之一

### 1.2.1 思路

思路一，记住如果到最后，没有K 个字符， i+k 里面可能存在空的数组。

i 作为索引，是一直以 2k 的方式在逐渐地扩大。但是，最终不能越界，总的长度

一旦超过了后，就意味着，后续没有k 个元素，就会出现空的数组啦。



```python

class Solution:
    def reverse_str(self, s: str, k: int) -> str:

        s = list(s)

        n = len(s)

        for i in range(0, n, 2 * k):

            s[i:i+k] = reversed(s[i:i+k])

        return "".join(s)
```




## 1.3 替换数字

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。

## 1.3.1 思路

思路，先统计数字，计算需要多少的空间，然后扩容之后，采用双指针的形式去做。

简单例子，字符串 "a5b" 的长度为3， 将一个number 之后，长度为8.

如果你从前面开始，每次增加一个，b 就需要移动，因此，从后面往前面更好。

整体的思路都是由后向前。

本质上来说，这里有2个数组，不是在原地操作，我的理解是因为python 无法直接对字符串进行原地操作。

```python

class Solution(object):
    def subsitute_numbers(self, s):
        """
        :type s: str
        :rtype: str
        """
        
        count = sum(1 for char in s if char.isdigit()) # 统计数字的个数
        #char.isdigit()：判断字符是否是数字
        expand_len = len(s) + (count * 5)  # 计算扩充后字符串的大小， x->number， 每有一个数字就要增加五个长度
        res = [''] * expand_len
        
        new_index = expand_len - 1 # 指向扩充后字符串末尾，写入新字符串 res

        old_index = len(s) - 1 # 指向原字符串末尾，读取原字符串 s
        
        while old_index >= 0: # 从后往前， 遇到数字替换成“number”
            if s[old_index].isdigit():
                res[new_index-5:new_index+1] = "number"
                new_index -= 6
            else:

            # 普通字符
                res[new_index] = s[old_index]
                new_index -= 1
            old_index -= 1
        
        return "".join(res)
        
        # 这里实际上就是遍历原数组，然后在放进去

if __name__ == "__main__":
    solution = Solution()

    while True:
        try:
            s = input()
            result = solution.subsitute_numbers(s)
            print(result)
        except EOFError:
            break
```

## 1.4 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：
输入: "the sky is blue"
输出: "blue is sky the"

示例 2：
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

## 1.4.1 思路 

思路，总体来说，思路还是比较简单的。先考虑特殊情况：反转后的字符不能包含空格，并且单词之间存在多余的空格也需要翻转。

采用双指针的方法，或者直接使用库使用。

直接把所有的先全部反转，然后在把单词在翻转，通过空格进行判断。

```python

class Solution():

    def reverse_word(self, s: str)->str:

        new_s = list[s]

        n = len(new_s)

        for i in range(n):

            if new_s[i] == '' and new_s[n-1]


            







```





