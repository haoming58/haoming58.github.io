---
layout: note_with_toc
title: 字符串
description: Understanding strings, and practical implementations in algorithm problems
category: Code
subcategory: Algorithme
tags: [strings, Data Structure, Algorithm, Python]
permalink: /notes/strings/
redirect_from:
  - /notes/字符串/
---

# 字符串

字符串对于我来说，相对比较熟悉，因此， 不进行过多描述，直接进入代码实践。 


## 1.1 代码实践

## 1.1 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

示例 2：
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]


### 1.1.1 思路

思路一，使用 for 循环

```python

class Solution():

    def reverse_str(self, word: str) -> str:
        n = len(word) - 1
        result = []

        while n >= 0:
            result.append(word[n])
            n = n - 1

        return "".join(result)
      
```

思路二，采用双指针的方式。 
str 是数组的形式的话，就不用自己在进行创建数组。


```python
class Solution:
    def reverse_str(self, word: str) -> str:
        chars = list(word)   # 字符串 → 列表
        left = 0
        right = len(chars) - 1

        while left < right:
            chars[left], chars[right] = chars[right], chars[left]
            left += 1
            right -= 1

        return "".join(chars)  # 列表 → 字符串

```

思路三，使用栈

后进先出（LIFO）

```python

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        stack = []
        for char in s:
            stack.append(char)
        for i in range(len(s)):
            s[i] = stack.pop()

```

思路四，也是双指针，但是是更简单版本


```python
class Solution():
  def reversestr(self, s:list[str])->None:

    n = len(s)

    for i in range(n//2):
     s[i], s[n - i - 1] = s[n - i - 1], s[i]

```

思路五，直接使用库函数进行操作。或者使用切片

s.reverse() / s[::-1]


## 1.2 反转字符串II

给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。

如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

示例:

输入: s = "abcdefg", k = 2
输出: "bacdfeg"

Python 切片越界不会报错，会自动截断

这是面试和刷题中常用切片而不用索引的原因之一

### 1.2.1 思路

思路一，记住如果到最后，没有K 个字符， i+k 里面可能存在空的数组。

i 作为索引，是一直以 2k 的方式在逐渐地扩大。但是，最终不能越界，总的长度

一旦超过了后，就意味着，后续没有k 个元素，就会出现空的数组啦。



```python

class Solution:
    def reverse_str(self, s: str, k: int) -> str:

        s = list(s)

        n = len(s)

        for i in range(0, n, 2 * k):

            s[i:i+k] = reversed(s[i:i+k])

        return "".join(s)
```




## 1.3 替换数字

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。

## 1.3.1 思路

思路，先统计数字，计算需要多少的空间，然后扩容之后，采用双指针的形式去做。

简单例子，字符串 "a5b" 的长度为3， 将一个number 之后，长度为8.

如果你从前面开始，每次增加一个，b 就需要移动，因此，从后面往前面更好。

整体的思路都是由后向前。

本质上来说，这里有2个数组，不是在原地操作，我的理解是因为python 无法直接对字符串进行原地操作。

```python

class Solution(object):
    def subsitute_numbers(self, s):
        """
        :type s: str
        :rtype: str
        """
        
        count = sum(1 for char in s if char.isdigit()) # 统计数字的个数
        #char.isdigit()：判断字符是否是数字
        expand_len = len(s) + (count * 5)  # 计算扩充后字符串的大小， x->number， 每有一个数字就要增加五个长度
        res = [''] * expand_len
        
        new_index = expand_len - 1 # 指向扩充后字符串末尾，写入新字符串 res

        old_index = len(s) - 1 # 指向原字符串末尾，读取原字符串 s
        
        while old_index >= 0: # 从后往前， 遇到数字替换成“number”
            if s[old_index].isdigit():
                res[new_index-5:new_index+1] = "number"
                new_index -= 6
            else:

            # 普通字符
                res[new_index] = s[old_index]
                new_index -= 1
            old_index -= 1
        
        return "".join(res)
        
        # 这里实际上就是遍历原数组，然后在放进去

if __name__ == "__main__":
    solution = Solution()

    while True:
        try:
            s = input()
            result = solution.subsitute_numbers(s)
            print(result)
        except EOFError:
            break
```

## 1.4 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：
输入: "the sky is blue"
输出: "blue is sky the"

示例 2：
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

## 1.4.1 思路 

思路，总体来说，思路还是比较简单的。先考虑特殊情况：反转后的字符不能包含空格，并且单词之间存在多余的空格也需要翻转。

采用双指针的方法，或者直接使用库使用。

直接把所有的先全部反转，然后在把单词在翻转，通过空格进行判断。

```python

class Solution():

    def reverse_word(self, s: str)->str:

        new_s = list[s]

        n =len(new_s)


        for fast in range(n):

            for slow in range(n):

                if new_s[fast]!='': 

                    if new_[slow] !='': # 单词要有空格

                        new_[slow] = ''

                        slow += 1

                else:

                    
                    new[slow] = s[fast]
                    fast += 1
                     slow += 1



```


## 1.5 右旋字符串

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。

输出：输出共一行，为进行了右旋转操作后的字符串。

样例输入：

2
abcdefg 

样例输出：

fgabcde

## 1.5.1 思路

它提供的思路就是分段操作, 负负得正。

先翻转全部，在分段翻转。

思路五，直接使用库函数进行操作。或者使用切片

s.reverse() / s[::-1]


```python

class Solution:
    def right_string(self, s: str, k: int) -> str:
        # 字符串转为列表，方便原地修改
        new_s = list(s)
        n = len(new_s)
        k %= n  # 防止 k 大于字符串长度

        # 定义原地反转函数
        def reverse(left, right):
            while left < right:
                new_s[left], new_s[right] = new_s[right], new_s[left]
                left += 1
                right -= 1

        # 三次反转
        reverse(0, n - 1)      # 1. 整体反转
        reverse(0, k - 1)      # 2. 反转前 k 个字符
        reverse(k, n - 1)      # 3. 反转剩余字符
        
        #  s[::-1]
        #  s[k-1::-1]
        #  s[:k-1:-1]

        # return s[-k:] + s[:-k]

        return "".join(new_s)

```

如果是针对左边旋的话，先进行小区间的反向旋转，在最后进行整体旋转。

## 1.6 实现 strStr() + KMP 算法 

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1: 输入: haystack = "hello", needle = "ll" 输出: 2

示例 2: 输入: haystack = "aaaaa", needle = "bba" 输出: -1

说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。


这份笔记整理了 **KMP (Knuth-Morris-Pratt)** 算法的核心逻辑。它通过引入“前缀表”的概念，解决了暴力匹配中频繁回退、效率低下的问题。



### 1.6.1 KMP 算法介绍

在字符串匹配任务中，我们需要在 **文本串 (Text)** 中找到 **模式串 (Pattern)** 的出现位置。

* **文本串：** `aabaabaaf`
* **模式串：** `aabaaf`

#### 1. 为什么需要 KMP？

传统的暴力匹配法（For 循环嵌套）在匹配失败时，文本串的指针会回退到起始位置的下一个字符重新开始。

* **传统方式：** 从第一个 `a` 开始，失败；再从第二个 `a` 开始，失败…… 这种做法浪费了大量已经匹配过的信息。
* **KMP 方式：** 利用已知信息，让模式串直接跳到可能匹配的位置。例如：直接从第四个 `a` 开始匹配，避免了无效的重复比较。

#### 2. 核心工具：前缀表 (Prefix Table / LPS)

KMP 的本质是利用**最长相等前后缀**来避免浪费。

> **核心思想：** 当匹配中途失配时，我们不需要从头开始，而是询问：“前面已经匹配的部分里，有没有一段（后缀）和模式串的开头（前缀）是相同的？”

##### 前缀与后缀定义：

* **前缀：** 包含首字符，但不包含尾字符的所有子串。
* **后缀：** 包含尾字符，但不包含首字符的所有子串。

##### 例子解析：模式串 `aabaaf` 的前缀表计算

我们寻找每一个子串中，**最长的相等前后缀长度**：

1. `a`：无前后缀，长度为 **0**。
2. `aa`：前缀 `a`，后缀 `a`。相等长度为 **1**。
3. `aab`：前缀 `a, aa`；后缀 `b, ab`。无相等，长度为 **0**。
4. `aaba`：前缀 `a, aa, aab`；后缀 `a, ba, aba`。相等 `a`，长度为 **1**。
5. `aabaa`：前缀 `a, aa, aab, aaba`；后缀 `a, aa, baa, abaa`。相等 `aa`，长度为 **2**。
6. `aabaaf`：无相等前后缀，长度为 **0**。

#### 3. 前缀表 (LPS 数组) 结构

最终生成的 **LPS (Longest Prefix Suffix)** 数组如下：

| Index | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| **Pattern (P)** | a | a | b | a | a | f |
| **LPS (Next)** | 0 | 1 | 0 | 1 | 2 | 0 |

---

#### 4. KMP 如何利用前缀表进行匹配？

当模式串在某个位置发生 **失配 (Mismatch)** 时：

1. **文本串指针不动：** 已经扫描过的字符不再回退。
2. **模式串指针跳转：** 查看失配字符**前一个字符**在 LPS 数组中的值。

**原理说明：**
由于 `aabaa` 的前两个字符 `aa` 和失配前的后两个字符 `aa` 是完全重复的。

* 这意味着：我们已经默认模式串开头的 `aa` 已经匹配好了。
* 因此：模式串不需要从头比，而是直接跳过这 2 个字符，从第 3 个字符（即索引为 2 的 `b`）继续比对。



### 1.6.2 代码实现
