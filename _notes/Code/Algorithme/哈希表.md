---
layout: note_with_toc
title: 深入理解哈希表 (Hash Table)
description: Understanding hash tables, collision resolution, and practical implementations in algorithm problems
category: Code
subcategory: Algorithme
tags: [Hash Table, Data Structure, Algorithm, Python, Collision Resolution]
permalink: /notes/hash-table-explained/
redirect_from:
  - /notes/哈希表/
---

# 哈希表

## 1. 什么是哈希表

通俗理解：哈希表就是一个“超级数组”。
核心能力：它最主要的作用是快速判断一个元素是否出现在集合里。
效率对比：普通遍历查找：需要 $O(n)$ 的时间（一个个看）。
哈希表查找：只需要 $O(1)$ 的时间（直接跳到目标位置）。

- How：

将字符串 通过 hashCode 转化成一个整数。

对数组长度进行取模运算（% tableSize），得到最终的索引下标。

## 2. 哈希碰撞

“小李”和“小王”经过计算，都应该坐在“1号”座位上。这就是哈希碰撞。

计算出来，得到下标是一样的，出现了问题。

解决办法就是：

拉链法 (Chaining)“座位不够，加小板凳”。发
生冲突的位置不再只存一个元素，而是挂一个链表，所有冲突的元素都存在这个链表中。最常用。需要合理设置表的大小，避免链表过长导致退化成 $O(n)$ 查询。

线性探测法 (Linear Probing)“这个位置有人了，我找下一个空位”。如果 1 号位被占了，就去看看 2 号位空不空，以此类推。要求表的大小必须大于数据量（tableSize > dataSize），否则就没空位了。


## 3. 封装好的基本结构

### 3.1 set 

用于存储不重复的元素



1. std::unordered_set（最常用的“超级快乱序柜”）（哈希表）

你想找某个东西（比如“苹果”），你不需要翻箱倒柜，你只要喊一声“苹果”，它能瞬间告诉你箱子里有没有（这就是 $O(1)$ 的含义：不管箱子里有一万个还是一亿个东西，查找速度一样快）。

规则 A（无序）：你往里面扔东西，它随便放，完全没有顺序。你今天放“香蕉、苹果”，明天可能拿出来看是“苹果、香蕉”。

规则 B（不重复）：它不接受重复的东西。如果你已经放了一个“苹果”，再扔一个“苹果”进去，它会把它丢出来，说“已经有了！”。



2. std::set（严谨的“排序排重柜”）(红黑树)

红黑树是一种平衡二叉搜索树

规则 A（有序）：不管你什么时候往里加新字，它都会自动帮你按 A-Z 的顺序排好。哪怕你先存 Z，再存 A，它也会自动把 A 放到最前面。

规则 B（不重复）：字典里同一个字只会收录一次。


3. std::multiset（宽容的“排序存重柜”）

规则 A（有序）：它也自动帮你按顺序排好。

规则 B（可重复）：它允许重复！如果你记了两次“花了5元”，它会如实记录两条“花了5元”。



### 3.2 map 

Set（集合）：只存一个东西。（比如：只存“张三”）

Map（映射）：存一对东西  键值对（Key-Value）


1. std::unordered_map（最常用的“超快乱序电话簿”）

你输入名字“张三”（Key），它“嗖”的一下直接弹出他的电话号码（Value）。

规则 A（无序）：它内部并没有按 A-Z 给名字排序，可能“张三”存在第一个位置，“李四”存在以后的某个位置，毫无规律。

规则 B（Key 不重复）：一个名字只能登记一次。你不能有两个“张三”都在这个系统里。


2. std::map（严谨的“排序电话簿”）

规则 A（有序）：所有的名字（Key）都严格按照 A-Z 或者笔画顺序排好了。你想找“张三”，得先翻到 Z 开头的页面，再慢慢找。所以它比上面的“智能查询机”要慢一点点（$O(\log n)$）。规则 B（Key 不重复）：同样，一个名字只能出现一次。


3. std::multimap（宽容的“排序电话簿”）

总的来说，是牺牲了空间来换取时间。

## 3. 代码实践

### 3.1 有效的字母异位词 

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

说明: 你可以假设字符串只包含小写字母

字母异位词就是检查检查这两个字符串是否由完全相同的字母，是就是Ture， 不是就是 False

材料（字母）完全一样，只是排列组合的方式（顺序）不一样，就是对的。

### 3.1.1 思路

简单思路：

第一个字符串的每个字符，和第二个字符串进行比较。

路径:

    1. 长度要相等
    2. 由于语言是python，使用列表以用于获取索引，并且标记，防止重复验证
    3. 借用一个found this char 作为最终标记
    4. 整体是2层循环，当找到一个匹配的，一是标记，二是跳出内循环，进行下一个的匹配

```python
def check_your_idea_fixed(a, b):
    if len(a) != len(b):
        return False
        
    # 把 b 转换成列表，这样我们才能"划掉"里面的元素
    b_list = list(b)
    
    # 遍历 a 中的每一个字符
    for i in range(len(a)):
        found_this_char = False
        
        # 在 b_list 里找这个字符
        for j in range(len(b_list)):
            if a[i] == b_list[j]:
                found_this_char = True
                # 【关键一步】找到了就要"划掉"它，避免下次再被用到！
                # 我们把它设置成一个特殊符号，比如 None，表示这个位置空了
                b_list[j] = None 
                break 
        
        # 如果没找到，直接失败
        if not found_this_char:
            return False
            
    return True
```


Hash_tabe 思路： 数组

路径：

    1. offset，ASII 码对应字母a-z, 映射
    2. 定义一个数组hash[26]
    3. 找到第一组每个字母出现的频率
    4. 然后用第二个数组出现的概率

总体思路是这样的： 

字母表已经提取配置好，每个字母对应的下标从0开始。

只需要将 a 对应的下标理解为0， 你的字符 - a = 偏移量

a b c  d e f ......z

97 98 .............z 这是ASII 码

0 1 2 3 4 5 .......26

如果你的字母 s 出现了，s - a 的偏移量，刚好就可以是数组对应的下标，然后对数组进行加1. 最终，进行统计得到了HASH TABEL 数组，每个字符的统计频率的结果。

然后，利用这个数组进行，验证下一个字符串。

另外一个字符串，t - a 的偏移量,刚好就可以是数组对应的下标，然后对数组内容进行减1. 最终统计数组之和，若是0，则相等，若不是则就不对。 


因为，python 没有数组，所以列表

```python
class Solution:  # <-- 拼写修正 (sloution -> Solution)，类名首字母通常大写

    # 在类中的方法(函数)需要 'def' 关键字，并且第一个参数必须是 'self'
    def check(self, s, t):

        if len(s) != len(t):
            return False  # <-- 拼写修正 (false -> False)，布尔值首字母大写

        # 必须初始化一个包含 26 个 0 的列表，而不是 [0]
        hash_list = [0] * 26

        # --- 统计字符串 s ---
        for i in range(len(s)):  # <-- 'range(0, len(s))' 可以简化
            # 1. 访问字符串字符用方括号 s[i]，不是 s(i)
            # 2. 需要用 ord() 函数获取字符的 ASCII 值来计算索引
            index = ord(s[i]) - ord('a')
            hash_list[index] += 1  # <-- 列表赋值和自增的正确语法

        # --- 减去字符串 t ---
        for j in range(len(t)):  # <-- 循环语句末尾需要冒号 :
            # 1. 这里应该用第二个字符串 t 和 循环变量 j (即 t[j])
            # 2. 同样需要 ord()
            index = ord(t[j]) - ord('a')
            hash_list[index] -= 1  # <-- 列表赋值和自减的正确语法

        # --- 检查最终结果 ---
        # 你需要检查 hash_list 中的 *每一个* 元素是否都为 0
        for count in hash_list:
            if count != 0:
                # 只要有一个不为 0，就说明两个字符串不匹配
                return False

        # 如果循环结束，所有元素都为 0，说明匹配成功
        return True  # <-- 拼写修正 (Ture -> True)
```

第二种写法： 使用已经存在好的库

```python

# 定义一个名为 Solution 的类（class）。
# 在 LeetCode 这样的刷题平台中，这是一种常见的组织代码的方式。
class Solution:
    
    # 在 Solution 类中定义一个方法（函数）叫做 isAnagram。
    # self: Python 类中方法的第一个参数，代表类实例自身。
    # s: str: 第一个输入参数，类型提示(Type Hint)为 str (字符串)。
    # t: str: 第二个输入参数，类型提示(Type Hint)为 str (字符串)。
    # -> bool: 返回值类型提示，表示这个函数将返回一个 bool (布尔值，即 True 或 False)。
    def isAnagram(self, s: str, t: str) -> bool:

        # 从 Python 的 collections 库中导入 defaultdict。
        # defaultdict 是一种特殊的字典，当你访问一个不存在的键时，
        # 它会自动为你创建这个键，并赋予一个默认值。
        from collections import defaultdict
        
        # 创建一个 defaultdict，并指定默认值工厂为 int。
        # int() 会返回 0。
        # 这意味着如果访问 s_dict['某个不存在的键']，它会自动创建该键并赋值为 0。
        s_dict = defaultdict(int)
        t_dict = defaultdict(int)
        
        # --- 第一个循环：统计字符串 s ---
        # for x in s: 会遍历字符串 s 中的每一个字符 x。
        for x in s:
            # s_dict[x] += 1
            # 如果 x (例如 'a') 不在 s_dict 中，defaultdict 会先自动创建它：s_dict['a'] = 0。
            # 然后执行 += 1，使得 s_dict['a'] 变为 1。
            # 如果 x 已经存在，就直接在原有计数值上 +1。
            s_dict[x] += 1
        
        # --- 第二个循环：统计字符串 t ---
        # 这一步和上面完全一样，但是是为字符串 t 和 t_dict 进行计数。
        for x in t:
            t_dict[x] += 1
            
        # --- 最后一步：比较两个字典 ---
        # return s_dict == t_dict
        # 这是本算法的核心。Python 在比较两个字典 (dict 或 defaultdict) 时，
        # 会检查它们是否拥有：
        # 1. 完全相同的键（keys）。
        # 2. 并且每个键对应的值（values）也完全相同。
        #
        # 这完美契合了“字母异位词”的定义：
        # - s 和 t 必须有完全相同的字符种类 (相同的键)。
        # - s 和 t 中每种字符的数量必须完全相同 (相同的值)。
        #
        # 如果两个字典完全相等，返回 True，否则返回 False。
        return s_dict == t_dict
```


第三种写法：使用 counter 库，进行统计。
Counter 对象是一种特殊的 Python 字典（dictionary）

```python
class Solution(object):
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import Counter
        a_count = Counter(s)
        b_count = Counter(t)
        return a_count == b_count
```

总体来说核心是，设置一个一一对应的关系，然后统计。


### 3.2 两个数组的交集

题意：给定两个数组，编写一个函数来计算它们的交集。

输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序

数值限制 1000

示例 1：

```python

nums1 = [1,2,2,1]  nums2 = [2,2]

output = [2]

```

### 3.2.1 思路

思路一：

我首先想到的思路就是利用数组，或者计数器进行统计，因为，才从上面的

对两个数组或者hash 表 同一位置进行判断，如果同一位置的字母存储的数 同时不为0. 就是一个交集

这里有个前提就是将数字转化为字母，或者直接使用字典之类的, 不过这种仅仅限制到26 个字母，所以部太可能。

所以，利用数组进行暴力循环，就直接判断值相等就行。


```python

class Solution:
    # 注意：我把类型提示改成了 list[int]，这更准确
    
    def intersection(self, nums1: list[int], nums2: list[int]):

        output = []
        
        # i 会依次成为 nums1 中的每个元素 (值)，例如 1, 2, 2, 1
        for i in nums1:
            # j 会依次成为 nums2 中的每个元素 (值)，例如 2, 2
            for j in nums2:
                
                # 修复 1：直接比较元素的值 i 和 j
                # (而不是像你之前那样把它们用作索引)
                if i == j:
                    
                    # 修复 3：为了保证交集结果的唯一性，
                    # 只有当这个元素还不在 output 里时，才添加它, 这个很关键
                    if i not in output: 
                        
                        # 修复 2：使用 .append() 来添加单个元素
                        output.append(i)

        return output
```

思路二：  数组

注意数值限制，因为数值可能无法存储很大,限定了1000个的值, 首先限定了数组是一个1000的字.

将其本身的数值当作索引，{key - value}, 数组的下标就是本身数值，然后实际的值就是次数

[1,2,5,6,5]
[1,2,5]



```python
from typing import list

class Solution
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        
        count1 = [0]*1001
        count2 = [0]*1001
        result = []

        for i in range(len(nums1)):
            count1[nums1[i]]+=1
        
        for j in range(len(nums2)):
            count2[nums2[j]]+=1

        for k in range(1001): # 最终，返回的是交集，就是本身数值，这里当作索引，因此，结果返回的就是索引
            if count1[k]*count2[k]:
                result.append(k) 
        return result
```



思路三： 使用字典和集合

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
    # 使用哈希表存储一个数组中的所有元素
        table = {} # 这里的hash表就是字典
        for num in nums1:  # 这里因为是字典，get(num, 0) 这里就是验证如果字

        # 意味着，如果里面字典不存在的话，就会返回0 ，并且加1. 如果存在就直接加1
            table[num] = table.get(num, 0) + 1
        
        # 使用集合存储结果
        res = set()
        for num in nums2:
            if num in table: # 检查第二个list 里面的每一个数值是否在第一个table里面
                res.add(num) # 如果存在的话，就直接放进set这个集合里面
                del table[num] # 并且删除这个本身在table 中的元素，防止重复
        return list(res) # s最终返回这个list 本身存在的结果
```

思路四： 直接使用set 本身的结构


```python

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))

```


### 3.3 快乐数

题意：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False

输入：19
输出：true

示例 ：

$$1^2 + 9^2 = 1 + 81 = 82$$

$$8^2 + 2^2 = 64 + 4 = 68$$

$$6^2 + 8^2 = 36 + 64 = 100$$

$$1^2 + 0^2 + 0^2 = 1 + 0 + 0 = 1$$

### 3.3.1 思路

判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。 将其放入哈希表，用于检查，或者说元素查询。

思路一：使用 set 集合记录已经出现过的数字。在不断计算“各位数字平方和”的过程中，判断是否应该继续循环。继续循环需要同时满足两个条件：

1. 当前计算结果不等于 1（还没成为快乐数）

2. 当前数字没有在之前出现过（避免进入循环）

在每一次循环中，应该先判断当前数字是否为 1；
如果不是，则将它加入 set，然后继续计算该数字的平方和，进入下一轮判断。

最终就能判断是否是快乐数

```python 
class Solution:
    def isHappy(self, n: int) -> bool:
        record = set()          # 用来记录出现过的数字，避免循环

        while n != 1:
            if n in record:     # 若重复出现 → 死循环 → 不是快乐数
                return False

            record.add(n)       # 记录当前数字
            n = self.get_next(n)  # 得到下一个数字：各位平方和

        return True

    def get_next(self, n: int) -> int:
        total = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total += digit * digit
        return total

```
思路二， 还有其他非常类似的写法

```python

class Solution:
    def isHappy(self, n: int) -> bool:

        record = set()

        while True:
            
            record.add(n)

            n = self.get_sum(n)

            if n == 1:
                return True

            if n in record:
                return False      
```

思路三，采用字符串，利用一个 set（集合）记录所有出现过的数字，避免出现循环。

record 是为了防止无限循环，new_result 存放“下一轮需要计算的数字”

因为 n 是你当前判断的数字，你不能一边遍历 n 的每一位，一边破坏 n 的原值，否则无法记录它、无法加入到 record。

1. 保留旧 n

2. 用 new_result 来构造新数字

```python

class Solution:

    def isHappy(self, n :int) -> bool:

        record = set()

        while n not in record:

            record.add(n)

            new_result = 0

            for digit in str(n):

                new_result += int(digit) ** 2

            if new_result == 1:
                
                return True
            
            else:

                n = new_result

        return False

```

思路四，使用list，和上方一样的思路。

```python

class Solution:

    def isHappy(self, n: int) -> bool:

        record = []     # list 查找 O(n)，不如 set 的 O(1)

        while n not in record:

            record.append(n)

            new_num = 0

            for i in str(n):
                new_num += int(i)**2

            if new_num == 1:
                return True
            else:
                n = new_num

        return False
```

## 3.4 两数之和

题意：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例：

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

### 3.4.1 思路

思路一， 直接使用双重循环，类似使用 for 循环进行使用

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        l = len(nums)
        for i in range(l):
            for j in range(i + 1, l):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return None

```
思路二，本质上来说就是给数字建立 下标 和 value， 而教学中提到的就是使用map会自动建立引用,并且采用减法,在python中，并不存在map，因此，采用这个{}

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        seem = {}

        for i, num in enumerate(nums):
            
            diff = target - num
            if diff in seen:
                return[seen[diff],i]
            else:
                seen[num]=i
        return []
```

同样，采用set() 也可以，都是借助enumerate 生成下标和对应的value

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        
        seem = set()

        for i, num in enumerate(nums):
            
            diff = target - num
            if diff in seen:
                return[nums.index[diff],i] # 这里就需要注意一波
            else:
                see.add(num)
```

思路三，使用双指针法：

两个指针分别在最左边和最右边，由于已经排好顺序，如果不排序的话，跟暴力循环每啥区别： 因为，不然怎么判断你的两个指针谁先走，本身这个就是利用二分法去探究这个值，只是说这种思路确实挺有意思的。

和太小，就需要把左边的向右边移，和太大的话，就需要把右边向左移动。

不够这里需要注意一个特殊情况是数值相同，但是下标不一样

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) - > list[int]:

        nums_sorted = sorted(nums)

        left = 0
        right = len(nums_sorted) - 1
        while left < right:
            current_sum = nums_sorted[left] + nums_sorted[right]

            if current_sum == target:

                left_index = nums.index(nums_sorted[left])
                right_index = nums.index(nums_sorted[right])
                # 假设 nums_sorted = [3, 3], target = 6, 这个特殊情况很重要
        #如果发现两个下标一样，说明我们遇到了两个数值相同的元素。对于第二个下标，我们需要从第一个下标的后一位开始找：
        #切片（Slice）、查找（Search）、复原（Restore）
                if left_index == right_index:
                    right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1
            elif current_sum < target:

                    # 如果总和小于目标，则将左侧指针向右移动
                left += 1
            else:
                # 如果总和大于目标值，则将右指针向左移动
                right -= 1
```
由于上述的情况不是很清楚，因此可以加入例子讲解。

nums = [1, 3, 3, 7]  target = 6

nums_sorted = [1, 3, 3, 7]

left 指向第一个 3。left =  1

right 指向第二个 3。right = 2  

3 + 3 = 6，找到答案

此时 left_index = right_index = nums.index（nums_sorted（1））= nums.index（nums_sorted（2））

nums.index(3) = 1 

nums.index(3) = 1 

left_index 和 right_index 相同了，但是实际上，right_index = 2

因此，为了避免这种情况，首先情况是已经知道left_index 这个肯定是没问题的，因此，就使用新的数组 nums[left_index+1:] ，然后还是一样的方法，

nums.index（nums_sorted（right_index））,但是注意这里删除了前面left_index+1 的索引，所以最终需要加回来，整个流程就是这样





