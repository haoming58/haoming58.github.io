# 哈希表

## 1. 什么是哈希表

通俗理解：哈希表就是一个“超级数组”。
核心能力：它最主要的作用是快速判断一个元素是否出现在集合里。
效率对比：普通遍历查找：需要 $O(n)$ 的时间（一个个看）。
哈希表查找：只需要 $O(1)$ 的时间（直接跳到目标位置）。

- How：

将字符串 通过 hashCode 转化成一个整数。

对数组长度进行取模运算（% tableSize），得到最终的索引下标。

## 2. 哈希碰撞

“小李”和“小王”经过计算，都应该坐在“1号”座位上。这就是哈希碰撞。

计算出来，得到下标是一样的，出现了问题。

解决办法就是：

拉链法 (Chaining)“座位不够，加小板凳”。发生冲突的位置不再只存一个元素，而是挂一个链表，所有冲突的元素都存在这个链表中。最常用。需要合理设置表的大小，避免链表过长导致退化成 $O(n)$ 查询。

线性探测法 (Linear Probing)“这个位置有人了，我找下一个空位”。如果 1 号位被占了，就去看看 2 号位空不空，以此类推。要求表的大小必须大于数据量（tableSize > dataSize），否则就没空位了。


## 3. 封装好的基本结构

### 3.1 set 

用于存储不重复的元素



1. std::unordered_set（最常用的“超级快乱序柜”）（哈希表）

你想找某个东西（比如“苹果”），你不需要翻箱倒柜，你只要喊一声“苹果”，它能瞬间告诉你箱子里有没有（这就是 $O(1)$ 的含义：不管箱子里有一万个还是一亿个东西，查找速度一样快）。

规则 A（无序）：你往里面扔东西，它随便放，完全没有顺序。你今天放“香蕉、苹果”，明天可能拿出来看是“苹果、香蕉”。

规则 B（不重复）：它不接受重复的东西。如果你已经放了一个“苹果”，再扔一个“苹果”进去，它会把它丢出来，说“已经有了！”。



2. std::set（严谨的“排序排重柜”）(红黑树)

红黑树是一种平衡二叉搜索树

规则 A（有序）：不管你什么时候往里加新字，它都会自动帮你按 A-Z 的顺序排好。哪怕你先存 Z，再存 A，它也会自动把 A 放到最前面。

规则 B（不重复）：字典里同一个字只会收录一次。


3. std::multiset（宽容的“排序存重柜”）

规则 A（有序）：它也自动帮你按顺序排好。

规则 B（可重复）：它允许重复！如果你记了两次“花了5元”，它会如实记录两条“花了5元”。



### 3.2 map 

Set（集合）：只存一个东西。（比如：只存“张三”）

Map（映射）：存一对东西  键值对（Key-Value）


1. std::unordered_map（最常用的“超快乱序电话簿”）

你输入名字“张三”（Key），它“嗖”的一下直接弹出他的电话号码（Value）。

规则 A（无序）：它内部并没有按 A-Z 给名字排序，可能“张三”存在第一个位置，“李四”存在以后的某个位置，毫无规律。

规则 B（Key 不重复）：一个名字只能登记一次。你不能有两个“张三”都在这个系统里。


2. std::map（严谨的“排序电话簿”）

规则 A（有序）：所有的名字（Key）都严格按照 A-Z 或者笔画顺序排好了。你想找“张三”，得先翻到 Z 开头的页面，再慢慢找。所以它比上面的“智能查询机”要慢一点点（$O(\log n)$）。规则 B（Key 不重复）：同样，一个名字只能出现一次。


3. std::multimap（宽容的“排序电话簿”）

总的来说，是牺牲了空间来换取时间。

## 3. 代码实践

### 3.1 有效的字母异位词 

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

说明: 你可以假设字符串只包含小写字母

字母异位词就是检查检查这两个字符串是否由完全相同的字母，是就是Ture， 不是就是 False

材料（字母）完全一样，只是排列组合的方式（顺序）不一样，就是对的。

#### 3.1.1 思路

简单思路：

第一个字符串的每个字符，和第二个字符串进行比较。

路径:

    1. 长度要相等
    2. 由于语言是python，使用列表以用于获取索引，并且标记，防止重复验证
    3. 借用一个found this char 作为最终标记
    4. 整体是2层循环，当找到一个匹配的，一是标记，二是跳出内循环，进行下一个的匹配

```python
def check_your_idea_fixed(a, b):
    if len(a) != len(b):
        return False
        
    # 把 b 转换成列表，这样我们才能"划掉"里面的元素
    b_list = list(b)
    
    # 遍历 a 中的每一个字符
    for i in range(len(a)):
        found_this_char = False
        
        # 在 b_list 里找这个字符
        for j in range(len(b_list)):
            if a[i] == b_list[j]:
                found_this_char = True
                # 【关键一步】找到了就要"划掉"它，避免下次再被用到！
                # 我们把它设置成一个特殊符号，比如 None，表示这个位置空了
                b_list[j] = None 
                break 
        
        # 如果没找到，直接失败
        if not found_this_char:
            return False
            
    return True
```


Hash_tabe 思路： 数组

路径：

    1. offset，ASII 码对应字母a-z, 映射
    2. 定义一个数组hash[26]
    3. 找到第一组每个字母出现的频率
    4. 然后用第二个数组出现的概率

总体思路是这样的： 

字母表已经提取配置好，每个字母对应的下标从0开始。

只需要将 a 对应的下标理解为0， 你的字符 - a = 偏移量

a b c  d e f ......z

97 98 .............z 这是ASII 码

0 1 2 3 4 5 .......26

如果你的字母 s 出现了，s - a 的偏移量，刚好就可以是数组对应的下标，然后对数组进行加1. 最终，进行统计得到了HASH TABEL 数组，每个字符的统计频率的结果。

然后，利用这个数组进行，验证下一个字符串。

另外一个字符串，t - a 的偏移量,刚好就可以是数组对应的下标，然后对数组内容进行减1. 最终统计数组之和，若是0，则相等，若不是则就不对。 


因为，python 没有数组，所以列表

```python
class Solution:  # <-- 拼写修正 (sloution -> Solution)，类名首字母通常大写

    # 在类中的方法(函数)需要 'def' 关键字，并且第一个参数必须是 'self'
    def check(self, s, t):

        if len(s) != len(t):
            return False  # <-- 拼写修正 (false -> False)，布尔值首字母大写

        # 必须初始化一个包含 26 个 0 的列表，而不是 [0]
        hash_list = [0] * 26

        # --- 统计字符串 s ---
        for i in range(len(s)):  # <-- 'range(0, len(s))' 可以简化
            # 1. 访问字符串字符用方括号 s[i]，不是 s(i)
            # 2. 需要用 ord() 函数获取字符的 ASCII 值来计算索引
            index = ord(s[i]) - ord('a')
            hash_list[index] += 1  # <-- 列表赋值和自增的正确语法

        # --- 减去字符串 t ---
        for j in range(len(t)):  # <-- 循环语句末尾需要冒号 :
            # 1. 这里应该用第二个字符串 t 和 循环变量 j (即 t[j])
            # 2. 同样需要 ord()
            index = ord(t[j]) - ord('a')
            hash_list[index] -= 1  # <-- 列表赋值和自减的正确语法

        # --- 检查最终结果 ---
        # 你需要检查 hash_list 中的 *每一个* 元素是否都为 0
        for count in hash_list:
            if count != 0:
                # 只要有一个不为 0，就说明两个字符串不匹配
                return False

        # 如果循环结束，所有元素都为 0，说明匹配成功
        return True  # <-- 拼写修正 (Ture -> True)
```

第二种写法： 使用已经存在好的库

```python

# 定义一个名为 Solution 的类（class）。
# 在 LeetCode 这样的刷题平台中，这是一种常见的组织代码的方式。
class Solution:
    
    # 在 Solution 类中定义一个方法（函数）叫做 isAnagram。
    # self: Python 类中方法的第一个参数，代表类实例自身。
    # s: str: 第一个输入参数，类型提示(Type Hint)为 str (字符串)。
    # t: str: 第二个输入参数，类型提示(Type Hint)为 str (字符串)。
    # -> bool: 返回值类型提示，表示这个函数将返回一个 bool (布尔值，即 True 或 False)。
    def isAnagram(self, s: str, t: str) -> bool:

        # 从 Python 的 collections 库中导入 defaultdict。
        # defaultdict 是一种特殊的字典，当你访问一个不存在的键时，
        # 它会自动为你创建这个键，并赋予一个默认值。
        from collections import defaultdict
        
        # 创建一个 defaultdict，并指定默认值工厂为 int。
        # int() 会返回 0。
        # 这意味着如果访问 s_dict['某个不存在的键']，它会自动创建该键并赋值为 0。
        s_dict = defaultdict(int)
        t_dict = defaultdict(int)
        
        # --- 第一个循环：统计字符串 s ---
        # for x in s: 会遍历字符串 s 中的每一个字符 x。
        for x in s:
            # s_dict[x] += 1
            # 如果 x (例如 'a') 不在 s_dict 中，defaultdict 会先自动创建它：s_dict['a'] = 0。
            # 然后执行 += 1，使得 s_dict['a'] 变为 1。
            # 如果 x 已经存在，就直接在原有计数值上 +1。
            s_dict[x] += 1
        
        # --- 第二个循环：统计字符串 t ---
        # 这一步和上面完全一样，但是是为字符串 t 和 t_dict 进行计数。
        for x in t:
            t_dict[x] += 1
            
        # --- 最后一步：比较两个字典 ---
        # return s_dict == t_dict
        # 这是本算法的核心。Python 在比较两个字典 (dict 或 defaultdict) 时，
        # 会检查它们是否拥有：
        # 1. 完全相同的键（keys）。
        # 2. 并且每个键对应的值（values）也完全相同。
        #
        # 这完美契合了“字母异位词”的定义：
        # - s 和 t 必须有完全相同的字符种类 (相同的键)。
        # - s 和 t 中每种字符的数量必须完全相同 (相同的值)。
        #
        # 如果两个字典完全相等，返回 True，否则返回 False。
        return s_dict == t_dict
```


第三种写法：使用 counter 库，进行统计。
Counter 对象是一种特殊的 Python 字典（dictionary）

```python
class Solution(object):
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import Counter
        a_count = Counter(s)
        b_count = Counter(t)
        return a_count == b_count
```

总体来说核心是，设置一个一一对应的关系，然后统计。


### 3.2 两个数组的交集