# 哈希表

## 1. 什么是哈希表

通俗理解：哈希表就是一个“超级数组”。
核心能力：它最主要的作用是快速判断一个元素是否出现在集合里。
效率对比：普通遍历查找：需要 $O(n)$ 的时间（一个个看）。
哈希表查找：只需要 $O(1)$ 的时间（直接跳到目标位置）。

- How：

将字符串 通过 hashCode 转化成一个整数。

对数组长度进行取模运算（% tableSize），得到最终的索引下标。

## 2. 哈希碰撞

“小李”和“小王”经过计算，都应该坐在“1号”座位上。这就是哈希碰撞。

计算出来，得到下标是一样的，出现了问题。

解决办法就是：

拉链法 (Chaining)“座位不够，加小板凳”。发生冲突的位置不再只存一个元素，而是挂一个链表，所有冲突的元素都存在这个链表中。最常用。需要合理设置表的大小，避免链表过长导致退化成 $O(n)$ 查询。

线性探测法 (Linear Probing)“这个位置有人了，我找下一个空位”。如果 1 号位被占了，就去看看 2 号位空不空，以此类推。要求表的大小必须大于数据量（tableSize > dataSize），否则就没空位了。


## 3. 封装好的基本结构

### 3.1 set 

用于存储不重复的元素



1. std::unordered_set（最常用的“超级快乱序柜”）（哈希表）

你想找某个东西（比如“苹果”），你不需要翻箱倒柜，你只要喊一声“苹果”，它能瞬间告诉你箱子里有没有（这就是 $O(1)$ 的含义：不管箱子里有一万个还是一亿个东西，查找速度一样快）。

规则 A（无序）：你往里面扔东西，它随便放，完全没有顺序。你今天放“香蕉、苹果”，明天可能拿出来看是“苹果、香蕉”。

规则 B（不重复）：它不接受重复的东西。如果你已经放了一个“苹果”，再扔一个“苹果”进去，它会把它丢出来，说“已经有了！”。



2. std::set（严谨的“排序排重柜”）(红黑树)

红黑树是一种平衡二叉搜索树

规则 A（有序）：不管你什么时候往里加新字，它都会自动帮你按 A-Z 的顺序排好。哪怕你先存 Z，再存 A，它也会自动把 A 放到最前面。

规则 B（不重复）：字典里同一个字只会收录一次。


3. std::multiset（宽容的“排序存重柜”）

规则 A（有序）：它也自动帮你按顺序排好。

规则 B（可重复）：它允许重复！如果你记了两次“花了5元”，它会如实记录两条“花了5元”。



### 3.2 map 

Set（集合）：只存一个东西。（比如：只存“张三”）

Map（映射）：存一对东西  键值对（Key-Value）


1. std::unordered_map（最常用的“超快乱序电话簿”）

你输入名字“张三”（Key），它“嗖”的一下直接弹出他的电话号码（Value）。

规则 A（无序）：它内部并没有按 A-Z 给名字排序，可能“张三”存在第一个位置，“李四”存在以后的某个位置，毫无规律。

规则 B（Key 不重复）：一个名字只能登记一次。你不能有两个“张三”都在这个系统里。


2. std::map（严谨的“排序电话簿”）

规则 A（有序）：所有的名字（Key）都严格按照 A-Z 或者笔画顺序排好了。你想找“张三”，得先翻到 Z 开头的页面，再慢慢找。所以它比上面的“智能查询机”要慢一点点（$O(\log n)$）。规则 B（Key 不重复）：同样，一个名字只能出现一次。


3. std::multimap（宽容的“排序电话簿”）

总的来说，是牺牲了空间来换取时间。

## 3. 代码实践

### 3.1 有效的字母异位词 

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

说明: 你可以假设字符串只包含小写字母

字母异位词就是检查检查这两个字符串是否由完全相同的字母，是就是Ture， 不是就是 False

材料（字母）完全一样，只是排列组合的方式（顺序）不一样，就是对的。

#### 3.1.1 思路

简单思路：

第一个字符串的每个字符，和第二个字符串进行比较。

路径:

    1. 长度要相等
    2. 由于语言是python，使用列表以用于获取索引，并且标记，防止重复验证
    3. 借用一个found this char 作为最终标记
    4. 整体是2层循环，当找到一个匹配的，一是标记，二是跳出内循环，进行下一个的匹配

```python
def check_your_idea_fixed(a, b):
    if len(a) != len(b):
        return False
        
    # 把 b 转换成列表，这样我们才能"划掉"里面的元素
    b_list = list(b)
    
    # 遍历 a 中的每一个字符
    for i in range(len(a)):
        found_this_char = False
        
        # 在 b_list 里找这个字符
        for j in range(len(b_list)):
            if a[i] == b_list[j]:
                found_this_char = True
                # 【关键一步】找到了就要"划掉"它，避免下次再被用到！
                # 我们把它设置成一个特殊符号，比如 None，表示这个位置空了
                b_list[j] = None 
                break 
        
        # 如果没找到，直接失败
        if not found_this_char:
            return False
            
    return True
```


Hash_tabe 思路：




